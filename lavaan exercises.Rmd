---
title: "Learning Lavaan"
output: html_notebook
---

Notes and code from: https://lavaan.ugent.be/tutorial/index.html

```{r loadpackages}
require(lavaan)
```
### Four formula types  

Use tilde for regression formula, e.g.  
y ~ x1 + x2 + x3

Use =~ for latent variables, can be read as 'measured by'  
e.g. 
f1 =~ y1 + y2 + y3

Double tilde for variances and covariances

y1 ~~ y1 #variance
y1 ~~ y2 #covariance

Intercepts for observed and latent have number 1 as only predictor  
y1 ~ 1

Complete model is a combination of formula types enclosed between single quotes.

For long models, can save in separate text file, e.g. myModel.lav, and then use readLines to read it in.

### Confirmatory factor analysis

Fit 3 factor model to HolzingerSwineford1939 dataset, with visual, textual and speed factors, all correlated.  

```{r cfa.demo}
head(HolzingerSwineford1939)
d<-HolzingerSwineford1939

HS.model <- '
visual =~ x1+x2+x3
textual =~ x4+x5+x6
speed =~ x7+x8+x9
'

fit <- cfa(HS.model,data=d)
summary(fit, fit.measures=TRUE)

```

2nd example is SEM model - will skip this for now, as I am interested in CFA.

### Fixing parameters

By default, lavaan fixes factor lading of first indicator to 1.

Other factor loadings can be fixed by specifying a factor loading, 

e.g. f =~ y1 + .5*y2

To fix the correlation between latent variables to zero, need to explicitly add a covariance-formula for this paper, and fix parameter to zero.

e.g. visual ~~ 0*speed

Also can fix the variance of a factor to 1.
If we do that, then use NA multiplier for the first variable loading on that factor - i.e. no longer necessary to fix it to 1, and it is now free.

Can also fix latent variables to be orthogonal by specifying orthogonal = T.

e.g. fit.HS.ortho <- cfa(HS.model,  
             data = d, orthogonal= TRUE)  
             
Also shortcut for fixing all latent variable variances to unity, std.lv = TRUE

Starting values automatically generated by lavaan, but can be provided by user.  

Can label a parameter with e.g.

f1 =~ x1 + x2 + myLabel*x3

Can be used for equality constraints

e.g. f1 =~ x1 + myLabel*x2 + myLabel*x3 = keeps x2 and x3 loadings equal

### Nonlinear equality and nonequality constraints

examples of how constraints can be applied

```{r constraints}
Data <- data.frame(y = rnorm(100),x1=rnorm(100),x2=rnorm(100),x3=rnorm(100))
model.constr <- 'y ~ b1*x1 + b2*x2 + b3*x3
#constraints
b1 == (b2+b3)^2
b1 > exp(b2+b3)
'
fit <- sem(model.constr, data=Data)
coef(fit)



```

### Means
can include intercept formulas

varx ~ 1

refers to intercept of varx

Rather than specifying intercepts for all observed vars, can just specify meanstructure = TRUE.  
The latent variable intercepts are shown but by default they are fit to zero, otherwise model would not be estimable.  

Only reason to bring intercept formulas explicitly into the model syntax is if we want to impose constraints.  


```{r withmeans}
fit <- cfa(HS.model,
           data = d,
           meanstructure=T)
summary(fit)

```
### Multiple groups  

Need to add name of group variable to argument group in the fitting function.
Example:  

```{r multgroups}
d<-HolzingerSwineford1939

HS.model <- '
visual =~ x1+x2+x3
textual =~ x4+x5+x6
speed =~ x7+x8+x9
'

fit <- cfa(HS.model,data=d,group="school")
summary(fit)


```

If you want to specify different loadings for different groups, can do it like this:

visual =~ x1 + .5*x2 +  c(.5, .8)*x3

here x1 and x2 are same loadings for both groups, whereas x3 has loading of .5 and .8 for the two groups respectively.

Can also specify start values differently for 2 groups in similar way.  

If you want to fix parameter for some group but not all , can use NA to indicate free, e.g.

visual =~ x1 + .5*x2 +  c(NA, .8)*x3

Constraining a single parameter to be equal across groups.  
Achieved by giving them the same label

visual =~ x1 + .5*x2 +  c(v3,v3)*x3

Identical labels imply identical parameters, both within and across groups.

Can also use generic term to make all parameters equal, e.g.

fit <- cfa(HS.model,data=d,group="school",group.equal=c("loadings"))

As well as loadings can also specify equality for intercepts (for observed variables), means (for latent variables), residuals (for observed variances), etc etc.

If group.equal is omitted, all parameters are freely estimated in each group but the model structure is the same.  

If you want to constrain most parameters to be same except for one or two, can specify exclusions with group.partial, e.g.

fit <- cfa(HS.model,data=d,group="school",
            group.equal=c("loadings"),
            group.partial = c("visual=~x2")
            
### Measurement invariance
Measurement invariance: attempts to verify that the estimated factors are measuring the same underlying latent construct within each group.

Does a number of multiple group analyses in a particular sequence, with increasingly more restrictions on the parameters.
This is in the semTools() package.  
Each model compared to basewline model and the previous model using chi square difference tests, and difference in fit measure is shown.

```{r measinvariance}
library(semTools)
measurementInvariance(model=HS.model,
                      data=HolzingerSwineford1939,
                      group="school")


```

### Growth curves
This looks v useful but not relevant so skip for now.  

### Categorical data 
Discusses binary and ordinal; classic coding with dummy variables. 
Using 'ordered' - which looks like a useful bit of baseR for ordering factor levels.

### Covariance matrix input 

Can use covariance input to model, provided you specify sample.nobs

e.g. fit <- sem(model1,
                sample.cov = mydat.cov,
                sample.nobs = 932)
                
                
With multiple groups, the sample.cov argument must be a list containing the sample variance-covariance matrix of each group as a separate element in the list. 
If a mean structure is needed, sample.mean argument must be a list containing sample means of each group.
Sample.nobs can be either a list or an integer vector containing n.obs for each group.  

### Estimators

Unbiased covariance with n-1 as multiplier for chi squ if you specify likelihood = "wishart"  
This is compatible with EQS, LISREL and AMOS.  

### Missing values 
- default is listwise deletion.  

### Standard errors
Based on expected information matrix.  
Can use robust.  

### Bootstrap  

can set se="bootstrap" or test ="bootstrap" to get bootstrap se.

### Mediation
Gives example of model.
Here we can have the ":=" operator = defintes new parameters which take on values that are arbitrary function of original model parameters.  

### Modification indices
Can ask for these

### Extracting information.
Summary function gives overview for display.  
To get actual values, you can use:
parameterEstimates(fit)  
standardizedSolution(fit)  
fitted(fit)  
residuals(fit)  
vcov(fit) - for estimated covariance matrix of parameter esimates

AIC(fit) and BIC(fit)  
fitMeasures(fit) - for all fit measures in a named numeric vector  

inspect(fit) - to see the model matrices used internally to represent the model.  


### Multilevel models
lavaan limited for multilevel, but you can specify 2 levels.  
(Looks like less good for this than other packages)


                


